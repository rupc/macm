#!/bin/bash
#알고리즘 문제 풀때 파일들 구조가 똑같고 같은 명령을 
#반복하기 귀찮기 때문에 쉘 스크립트로 자동적을 만들어준다
function usage() {
    echo "macm #problem | install"
}
echo $1
prob=$1
    
rstrconv"

if [ "$prob" == "install"]
# then
    # echo "install command"
    # lang=$2
    if [ -d $HOME/.config/macm/code-templates ]; then
        cp $HOME/.config/macm/code-templates . -r
        
        rcho "There is no code-templates in ~/.config/macm"
    fi
    "encoding/binary"
 
    r  # echo "Moved code-template $(pwd)"
    exit 0
fi



"crypto/sha1"
if [ -z "$prob" ]
then
    echo "Enter the name of problem(or number)"
    echo "Usage : macm #PROBLEM_NUMBER"
    kill -INT $$
    #exit 1
fi

if [ -e "$prob" ]
then
    # echo "Same problem already existsmd5
    kill -INT $$
    #exit 1


fi

mkdir "$prob"
mkdir "$Uint"
mkdir "$Int"
mkdir "$prob"
presult.Float())l
presult.Float())l
"type:", m"type:", 



type Block int {
time String64
bloc64
r_ind[]ex i64
string
r
hash int64
byte[]

s_result = result.String()
rdir String():
big.Mod, big.NewInt(32))
    latest_var lt_block Block
block_url    "strconv"



s_resulindex int
rbinary.BigEndianbig
Modmath.big.
r


rt64(Rem
QuoRem
r


pr      resul
# r
 

rang.time = gjson.Get(s, "time").Int()
lang.height = gjson.Get(s, "height").Int()
lang.Block = gjson.Get(s, "block_index").Int()
lang.hash = gjson.Get(s, "hashString
rrray(
pla
.time, lang.height, lang.Bloc
# r, lang.hashl
# r_

rtemplate resuParseIntstdrAtoi.String()
r 10 % 6result type c 
   
r
randomdsource = sha1.New()
    fmo.Printf("Hello, %
    r with type 
    r\n", lang.hash

    r

    bs := randomdsource.Sum(nil)
    res := new(bi..Int)
    re 
    var lucky_g big.Int

    lucky_guy uy = new(big.Int).SetBytes([]byte(latest_var.hash)).M6)od()
    []byte()    
    rerate cpp ))source file
    # rerate cpp math
    rNewInt(32
    rource file
if [ "$no_temp" = 0 ]
then
    # touch "$prob"/"$prob";
    
    ruluc
    ry_g:
    ry, NewInt(6))

    z := new(big.Int)
    z.SetBytes(b)
    pr 
    rv

    # z
     luc
     ry_guy % 6

     lucky_guy :=big.Mod(z, 6)
     rode to the problem folder
    cp $TEM_DIluck
    modulo := new(big.Int)
    module.SetBytes([]byte(strconv(Itoa(6))))
   
    r
    rtemplate.cpp ./"$prob"/
 
    r  # Change the namehash: of template source to problem.extensionanswkduf, zl) gudtlrdmfh rkqtdmf tnlqrp Rjsodhf tn dlTek. go wkcpdptj wprhdgownsms rjtqhek gnjfTls vusg
    ra."$b
    rR_DIR"/"$prob"/cpp-template.cpph"$CUR_DIR"/"$prob".getMany/time:"bloc
    r_index_prob\n
    r.cp
    r

    
    rnfos.ForEach(func(key, value gjson.Result)) bool {
    p:%s lv



key, value)
return true;
    t result := gjson.s(json, "programmers")
    result.ForEach(func(key, value gjson.Result) bool{
    fmt.Printf("%s:%s", key, value)
        #statements
    done




# Create binary folder if it doesn't exist
if [ ! -d $CUR_DIR/abin ]; then
    echo "binary directory created" 
    mkdir $CUR_DIR/abin
fi

# Generate input file, execute file and samples
touch "$CUR_DIR"/"$prob"/"$prob".in
touch "$CUR_DIR"/"$prob"/res
touch "$CUR_DIR"/"$prob"/samples
chmod +x $CUR_DIR/"$prob"/res
# default judge
JUDGE="boj"
echo -n "Your judge is" 
if [ "$JUDGE" == "boj" ]; then
    #statements
    echo $JUDGE
    curl -o $CUR_DIR/$prob/$prob.html https://www.acmicpc.net/problem/$prob
fi

# acm problem binary 
executable="abin"
extension=".cpp"
# -g : gdb debbuing info
# -pg : gprof profiling info
cflags="-std=c++14 -Wall -O2 -g -pg -DACMICPC -DDEBUG"
cxx="g++"
obj_loc=$CUR_DIR/abin/$prob
target=$prob
echo -n "g++ -o $CUR_DIR/abin/$prob $prob" >> "$CUR_DIR"/"$prob"/res
echo "$extension $cflags" >> "$CUR_DIR"/"$prob"/res
echo "chmod +x $CUR_DIR"/abin/"$prob" >> "$CUR_DIR"/"$prob"/res
echo "$CUR_DIR/abin/$prob < $prob.in" >> "$CUR_DIR"/"$prob"/res
#compile_cmd="g++ "
#printf "$cxx -o $obj_loc $prob$extension $cflags"

echo Lets solve $prob && cd $CUR_DIR/$prob

